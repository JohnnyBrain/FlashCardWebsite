{"ast":null,"code":"/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst'),\n    customUtils = require('./customUtils'),\n    util = require('util'),\n    _ = require('underscore');\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction AVLTree(options) {\n  this.tree = new _AVLTree(options);\n}\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction _AVLTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n/**\n * Inherit basic functions from the basic binary search tree\n */\n\n\nutil.inherits(_AVLTree, BinarySearchTree);\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\n\nAVLTree._AVLTree = _AVLTree;\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  } // Empty tree\n\n\n  if (this.left && this.left.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.left.key);\n  }\n\n  if (this.right && this.right.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.right.key);\n  }\n\n  if (this.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.key);\n  }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) {\n    throw new Error(\"Height constraint failed for node \" + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkHeightCorrect();\n  }\n\n  if (this.right) {\n    this.right.checkHeightCorrect();\n  }\n};\n/**\n * Return the balance factor\n */\n\n\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0,\n      rightH = this.right ? this.right.height : 0;\n  return leftH - rightH;\n};\n/**\n * Check that the balance factors are all between -1 and 1\n */\n\n\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) {\n    throw new Error('Tree is unbalanced at node ' + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkBalanceFactors();\n  }\n\n  if (this.right) {\n    this.right.checkBalanceFactors();\n  }\n};\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n\n\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\n\nAVLTree.prototype.checkIsAVLT = function () {\n  this.tree.checkIsAVLT();\n};\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.rightRotation = function () {\n  var q = this,\n      p = this.left,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!p) {\n    return this;\n  } // No change\n\n\n  b = p.right; // Alter tree structure\n\n  if (q.parent) {\n    p.parent = q.parent;\n\n    if (q.parent.left === q) {\n      q.parent.left = p;\n    } else {\n      q.parent.right = p;\n    }\n  } else {\n    p.parent = null;\n  }\n\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n\n  if (b) {\n    b.parent = q;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n  return p;\n};\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.leftRotation = function () {\n  var p = this,\n      q = this.right,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!q) {\n    return this;\n  } // No change\n\n\n  b = q.left; // Alter tree structure\n\n  if (p.parent) {\n    q.parent = p.parent;\n\n    if (p.parent.left === p) {\n      p.parent.left = q;\n    } else {\n      p.parent.right = q;\n    }\n  } else {\n    q.parent = null;\n  }\n\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n\n  if (b) {\n    b.parent = p;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n  return q;\n};\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) {\n    return this;\n  } // Right is not too small, don't change\n\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) {\n    return this;\n  } // Left is not too small, don't change\n\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n\n\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this,\n      rotated,\n      i;\n\n  if (!this.hasOwnProperty('key')) {\n    delete this.height;\n    return this;\n  } // Empty tree\n  // Rebalance the tree and update all heights\n\n\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n  }\n\n  return newRoot;\n};\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n\n\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = [],\n      currentNode = this; // Empty tree, insert as root\n\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  } // Insert new leaf at the right place\n\n\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n}; // Insert in the internal tree, update the pointer to the root if needed\n\n\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this,\n      currentNode = this,\n      deletePath = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return this;\n  } // Empty tree\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n\n\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) {\n      break;\n    }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this; // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this; // Key not found, no modification\n      }\n    }\n  } // Delete only a value (no tree modification)\n\n\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    currentNode.data = newData;\n    return this;\n  } // Delete a whole node\n  // Leaf\n\n\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {\n      // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with only one child\n\n\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {\n      // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n\n\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left; // Special case: the in-order predecessor is right below the node to delete\n\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n\n    if (replaceWith.left) {\n      replaceWith.left.parent = currentNode;\n    }\n\n    return this.rebalanceAlongPath(deletePath);\n  } // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n\n\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n  replaceWith.parent.right = replaceWith.left;\n\n  if (replaceWith.left) {\n    replaceWith.left.parent = replaceWith.parent;\n  }\n\n  return this.rebalanceAlongPath(deletePath);\n}; // Delete a value\n\n\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n\n\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n}); // Interface\n\nmodule.exports = AVLTree;","map":{"version":3,"names":["BinarySearchTree","require","customUtils","util","_","AVLTree","options","tree","_AVLTree","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","inherits","prototype","checkHeightCorrect","leftH","rightH","height","Error","Math","max","balanceFactor","checkBalanceFactors","abs","checkIsAVLT","super_","checkIsBST","call","rightRotation","q","p","b","ah","bh","ch","leftRotation","rightTooSmall","leftTooSmall","rebalanceAlongPath","path","newRoot","rotated","i","length","insert","insertPath","currentNode","push","err","errorType","createLeftChild","createRightChild","newTree","delete","newData","replaceWith","self","deletePath","forEach","d","fn","apply","arguments","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/binary-search-tree/lib/avltree.js"],"sourcesContent":["/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst')\n  , customUtils = require('./customUtils')\n  , util = require('util')\n  , _ = require('underscore')\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw new Error(\"Undefined height for node \" + this.left.key); }\n  if (this.right && this.right.height === undefined) { throw new Error(\"Undefined height for node \" + this.right.key); }\n  if (this.height === undefined) { throw new Error(\"Undefined height for node \" + this.key); }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error(\"Height constraint failed for node \" + this.key); }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key); }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}