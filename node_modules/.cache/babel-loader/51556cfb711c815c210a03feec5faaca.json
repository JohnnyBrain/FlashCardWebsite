{"ast":null,"code":"/**\n * Responsible for sequentially executing actions on the database\n */\nvar async = require('async');\n\nfunction Executor() {\n  this.buffer = [];\n  this.ready = false; // This queue will execute all commands, one-by-one in order\n\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = []; // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n\n    for (var i = 0; i < task.arguments.length; i += 1) {\n      newArguments.push(task.arguments[i]);\n    }\n\n    var lastArg = task.arguments[task.arguments.length - 1]; // Always tell the queue task is complete. Execute callback if any was given.\n\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n          setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () {\n        cb();\n      };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () {\n        cb();\n      });\n    }\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\n\n\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\n\n\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n\n  for (i = 0; i < this.buffer.length; i += 1) {\n    this.queue.push(this.buffer[i]);\n  }\n\n  this.buffer = [];\n}; // Interface\n\n\nmodule.exports = Executor;","map":{"version":3,"names":["async","require","Executor","buffer","ready","queue","task","cb","newArguments","i","arguments","length","push","lastArg","setImmediate","process","nextTick","apply","fn","this","prototype","forceQueuing","processBuffer","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/nedb/lib/executor.js"],"sourcesContent":["/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = require('async')\n  ;\n\nfunction Executor () {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n           setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () { cb(); };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () { cb(); });\n    }\n\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\n  this.buffer = [];\n};\n\n\n\n// Interface\nmodule.exports = Executor;\n"],"mappings":"AAAA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AAGA,SAASC,QAAT,GAAqB;EACnB,KAAKC,MAAL,GAAc,EAAd;EACA,KAAKC,KAAL,GAAa,KAAb,CAFmB,CAInB;;EACA,KAAKC,KAAL,GAAaL,KAAK,CAACK,KAAN,CAAY,UAAUC,IAAV,EAAgBC,EAAhB,EAAoB;IAC3C,IAAIC,YAAY,GAAG,EAAnB,CAD2C,CAG3C;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,SAAL,CAAeC,MAAnC,EAA2CF,CAAC,IAAI,CAAhD,EAAmD;MAAED,YAAY,CAACI,IAAb,CAAkBN,IAAI,CAACI,SAAL,CAAeD,CAAf,CAAlB;IAAuC;;IAC5F,IAAII,OAAO,GAAGP,IAAI,CAACI,SAAL,CAAeJ,IAAI,CAACI,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAd,CAL2C,CAO3C;;IACA,IAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;MACjC;MACAL,YAAY,CAACA,YAAY,CAACG,MAAb,GAAsB,CAAvB,CAAZ,GAAwC,YAAY;QAClD,IAAI,OAAOG,YAAP,KAAwB,UAA5B,EAAwC;UACrCA,YAAY,CAACP,EAAD,CAAZ;QACF,CAFD,MAEO;UACLQ,OAAO,CAACC,QAAR,CAAiBT,EAAjB;QACD;;QACDM,OAAO,CAACI,KAAR,CAAc,IAAd,EAAoBP,SAApB;MACD,CAPD;IAQD,CAVD,MAUO,IAAI,CAACG,OAAD,IAAYP,IAAI,CAACI,SAAL,CAAeC,MAAf,KAA0B,CAA1C,EAA6C;MAClD;MACAH,YAAY,CAACA,YAAY,CAACG,MAAb,GAAsB,CAAvB,CAAZ,GAAwC,YAAY;QAAEJ,EAAE;MAAK,CAA7D;IACD,CAHM,MAGA;MACL;MACAC,YAAY,CAACI,IAAb,CAAkB,YAAY;QAAEL,EAAE;MAAK,CAAvC;IACD;;IAGDD,IAAI,CAACY,EAAL,CAAQD,KAAR,CAAcX,IAAI,CAACa,IAAnB,EAAyBX,YAAzB;EACD,CA5BY,EA4BV,CA5BU,CAAb;AA6BD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,QAAQ,CAACkB,SAAT,CAAmBR,IAAnB,GAA0B,UAAUN,IAAV,EAAgBe,YAAhB,EAA8B;EACtD,IAAI,KAAKjB,KAAL,IAAciB,YAAlB,EAAgC;IAC9B,KAAKhB,KAAL,CAAWO,IAAX,CAAgBN,IAAhB;EACD,CAFD,MAEO;IACL,KAAKH,MAAL,CAAYS,IAAZ,CAAiBN,IAAjB;EACD;AACF,CAND;AASA;AACA;AACA;AACA;;;AACAJ,QAAQ,CAACkB,SAAT,CAAmBE,aAAnB,GAAmC,YAAY;EAC7C,IAAIb,CAAJ;EACA,KAAKL,KAAL,GAAa,IAAb;;EACA,KAAKK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKN,MAAL,CAAYQ,MAA5B,EAAoCF,CAAC,IAAI,CAAzC,EAA4C;IAAE,KAAKJ,KAAL,CAAWO,IAAX,CAAgB,KAAKT,MAAL,CAAYM,CAAZ,CAAhB;EAAkC;;EAChF,KAAKN,MAAL,GAAc,EAAd;AACD,CALD,C,CASA;;;AACAoB,MAAM,CAACC,OAAP,GAAiBtB,QAAjB"},"metadata":{},"sourceType":"script"}