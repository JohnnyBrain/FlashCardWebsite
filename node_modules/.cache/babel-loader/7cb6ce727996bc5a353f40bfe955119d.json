{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _objectSpread = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _objectWithoutProperties = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _defineProperty = require(\"/Users/johnbrain/Projects/FlashCardProject/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _excluded = [\"raw\", \"salt\"];\n\nvar _Object$freeze;\n\nvar assert = require(\"assert\");\n\nvar _require = require(\"crypto\"),\n    randomBytes = _require.randomBytes,\n    timingSafeEqual = _require.timingSafeEqual;\n\nvar _require2 = require(\"util\"),\n    promisify = _require2.promisify;\n\nvar _require3 = require(\"./lib/binding/napi-v3/argon2.node\"),\n    _hash = _require3.hash;\n\nvar _require4 = require(\"@phc/format\"),\n    deserialize = _require4.deserialize,\n    serialize = _require4.serialize;\n\nvar types = Object.freeze({\n  argon2d: 0,\n  argon2i: 1,\n  argon2id: 2\n});\nvar defaults = Object.freeze({\n  hashLength: 32,\n  saltLength: 16,\n  timeCost: 3,\n  memoryCost: 1 << 12,\n  parallelism: 1,\n  type: types.argon2id,\n  version: 0x13\n});\nvar limits = Object.freeze({\n  hashLength: {\n    min: 4,\n    max: Math.pow(2, 32) - 1\n  },\n  memoryCost: {\n    min: 1 << 10,\n    max: Math.pow(2, 32) - 1\n  },\n  timeCost: {\n    min: 2,\n    max: Math.pow(2, 32) - 1\n  },\n  parallelism: {\n    min: 1,\n    max: Math.pow(2, 24) - 1\n  }\n});\nvar names = Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, types.argon2d, \"argon2d\"), _defineProperty(_Object$freeze, types.argon2i, \"argon2i\"), _defineProperty(_Object$freeze, types.argon2id, \"argon2id\"), _Object$freeze));\nvar bindingsHash = promisify(_hash);\nvar generateSalt = promisify(randomBytes);\n\nvar assertLimits = function assertLimits(options) {\n  return function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        _ref2$ = _ref2[1],\n        max = _ref2$.max,\n        min = _ref2$.min;\n\n    var value = options[key];\n    assert(min <= value && value <= max, \"Invalid \".concat(key, \", must be between \").concat(min, \" and \").concat(max, \".\"));\n  };\n};\n\nvar hash = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(plain) {\n    var _ref4,\n        raw,\n        salt,\n        options,\n        hash,\n        _options,\n        type,\n        version,\n        m,\n        t,\n        p,\n        data,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref4 = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, raw = _ref4.raw, salt = _ref4.salt, options = _objectWithoutProperties(_ref4, _excluded);\n            options = _objectSpread(_objectSpread({}, defaults), options);\n            Object.entries(limits).forEach(assertLimits(options));\n            _context.t0 = salt;\n\n            if (_context.t0) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 7;\n            return generateSalt(options.saltLength);\n\n          case 7:\n            _context.t0 = _context.sent;\n\n          case 8:\n            salt = _context.t0;\n            _context.next = 11;\n            return bindingsHash(Buffer.from(plain), salt, options);\n\n          case 11:\n            hash = _context.sent;\n\n            if (!raw) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt(\"return\", hash);\n\n          case 14:\n            _options = options, type = _options.type, version = _options.version, m = _options.memoryCost, t = _options.timeCost, p = _options.parallelism, data = _options.associatedData;\n            return _context.abrupt(\"return\", serialize({\n              id: names[type],\n              version: version,\n              params: _objectSpread({\n                m: m,\n                t: t,\n                p: p\n              }, data ? {\n                data: data\n              } : {}),\n              salt: salt,\n              hash: hash\n            }));\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function hash(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar needsRehash = function needsRehash(digest, options) {\n  var _defaults$options = _objectSpread(_objectSpread({}, defaults), options),\n      memoryCost = _defaults$options.memoryCost,\n      timeCost = _defaults$options.timeCost,\n      version = _defaults$options.version;\n\n  var _deserialize = deserialize(digest),\n      v = _deserialize.version,\n      _deserialize$params = _deserialize.params,\n      m = _deserialize$params.m,\n      t = _deserialize$params.t;\n\n  return +v !== +version || +m !== +memoryCost || +t !== +timeCost;\n};\n\nvar verify = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(digest, plain, options) {\n    var obj, id, _obj$version, version, _obj$params, m, t, p, data, salt, hash;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            obj = deserialize(digest); // Only these have the \"params\" key, so if the password was encoded\n            // using any other method, the destructuring throws an error\n\n            if (obj.id in types) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 3:\n            id = obj.id, _obj$version = obj.version, version = _obj$version === void 0 ? 0x10 : _obj$version, _obj$params = obj.params, m = _obj$params.m, t = _obj$params.t, p = _obj$params.p, data = _obj$params.data, salt = obj.salt, hash = obj.hash;\n            _context2.t0 = timingSafeEqual;\n            _context2.next = 7;\n            return bindingsHash(Buffer.from(plain), salt, _objectSpread(_objectSpread({}, options), {}, {\n              type: types[id],\n              version: +version,\n              hashLength: hash.length,\n              memoryCost: +m,\n              timeCost: +t,\n              parallelism: +p\n            }, data ? {\n              associatedData: Buffer.from(data, \"base64\")\n            } : {}));\n\n          case 7:\n            _context2.t1 = _context2.sent;\n            _context2.t2 = hash;\n            return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t1, _context2.t2));\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function verify(_x2, _x3, _x4) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nmodule.exports = _objectSpread({\n  defaults: defaults,\n  limits: limits,\n  hash: hash,\n  needsRehash: needsRehash,\n  verify: verify\n}, types);","map":{"version":3,"names":["assert","require","randomBytes","timingSafeEqual","promisify","_hash","hash","deserialize","serialize","types","Object","freeze","argon2d","argon2i","argon2id","defaults","hashLength","saltLength","timeCost","memoryCost","parallelism","type","version","limits","min","max","names","bindingsHash","generateSalt","assertLimits","options","key","value","plain","raw","salt","entries","forEach","Buffer","from","m","t","p","data","associatedData","id","params","needsRehash","digest","v","verify","obj","length","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/argon2/argon2.js"],"sourcesContent":["\"use strict\";\nconst assert = require(\"assert\");\nconst { randomBytes, timingSafeEqual } = require(\"crypto\");\nconst { promisify } = require(\"util\");\n\nconst { hash: _hash } = require(\"./lib/binding/napi-v3/argon2.node\");\n\nconst { deserialize, serialize } = require(\"@phc/format\");\n\nconst types = Object.freeze({ argon2d: 0, argon2i: 1, argon2id: 2 });\n\nconst defaults = Object.freeze({\n  hashLength: 32,\n  saltLength: 16,\n  timeCost: 3,\n  memoryCost: 1 << 12,\n  parallelism: 1,\n  type: types.argon2id,\n  version: 0x13,\n});\n\nconst limits = Object.freeze({\n  hashLength: { min: 4, max: 2 ** 32 - 1 },\n  memoryCost: { min: 1 << 10, max: 2 ** 32 - 1 },\n  timeCost: { min: 2, max: 2 ** 32 - 1 },\n  parallelism: { min: 1, max: 2 ** 24 - 1 },\n});\n\nconst names = Object.freeze({\n  [types.argon2d]: \"argon2d\",\n  [types.argon2i]: \"argon2i\",\n  [types.argon2id]: \"argon2id\",\n});\n\nconst bindingsHash = promisify(_hash);\nconst generateSalt = promisify(randomBytes);\n\nconst assertLimits =\n  (options) =>\n  ([key, { max, min }]) => {\n    const value = options[key];\n    assert(\n      min <= value && value <= max,\n      `Invalid ${key}, must be between ${min} and ${max}.`\n    );\n  };\n\nconst hash = async (plain, { raw, salt, ...options } = {}) => {\n  options = { ...defaults, ...options };\n\n  Object.entries(limits).forEach(assertLimits(options));\n\n  salt = salt || (await generateSalt(options.saltLength));\n\n  const hash = await bindingsHash(Buffer.from(plain), salt, options);\n  if (raw) {\n    return hash;\n  }\n\n  const {\n    type,\n    version,\n    memoryCost: m,\n    timeCost: t,\n    parallelism: p,\n    associatedData: data,\n  } = options;\n  return serialize({\n    id: names[type],\n    version,\n    params: { m, t, p, ...(data ? { data } : {}) },\n    salt,\n    hash,\n  });\n};\n\nconst needsRehash = (digest, options) => {\n  const { memoryCost, timeCost, version } = { ...defaults, ...options };\n\n  const {\n    version: v,\n    params: { m, t },\n  } = deserialize(digest);\n  return +v !== +version || +m !== +memoryCost || +t !== +timeCost;\n};\n\nconst verify = async (digest, plain, options) => {\n  const obj = deserialize(digest);\n  // Only these have the \"params\" key, so if the password was encoded\n  // using any other method, the destructuring throws an error\n  if (!(obj.id in types)) {\n    return false;\n  }\n\n  const {\n    id,\n    version = 0x10,\n    params: { m, t, p, data },\n    salt,\n    hash,\n  } = obj;\n\n  return timingSafeEqual(\n    await bindingsHash(Buffer.from(plain), salt, {\n      ...options,\n      type: types[id],\n      version: +version,\n      hashLength: hash.length,\n      memoryCost: +m,\n      timeCost: +t,\n      parallelism: +p,\n      ...(data ? { associatedData: Buffer.from(data, \"base64\") } : {}),\n    }),\n    hash\n  );\n};\n\nmodule.exports = { defaults, limits, hash, needsRehash, verify, ...types };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}