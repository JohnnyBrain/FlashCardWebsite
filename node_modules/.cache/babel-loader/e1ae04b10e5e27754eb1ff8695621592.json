{"ast":null,"code":"var customUtils = require('./customUtils'),\n    model = require('./model'),\n    async = require('async'),\n    Executor = require('./executor'),\n    Index = require('./indexes'),\n    util = require('util'),\n    _ = require('underscore'),\n    Persistence = require('./persistence'),\n    Cursor = require('./cursor');\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\n\n\nfunction Datastore(options) {\n  var filename; // Retrocompatibility with v0.6 and before\n\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false; // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  } // Determine whether in memory or persistent\n\n\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  } // String comparison function\n\n\n  this.compareStrings = options.compareStrings; // Persistence handling\n\n  this.persistence = new Persistence({\n    db: this,\n    nodeWebkitAppName: options.nodeWebkitAppName,\n    afterSerialization: options.afterSerialization,\n    beforeDeserialization: options.beforeDeserialization,\n    corruptAlertThreshold: options.corruptAlertThreshold\n  }); // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n\n  this.executor = new Executor();\n\n  if (this.inMemoryOnly) {\n    this.executor.ready = true;\n  } // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n\n\n  this.indexes = {};\n  this.indexes._id = new Index({\n    fieldName: '_id',\n    unique: true\n  });\n  this.ttlIndexes = {}; // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n\n  if (this.autoload) {\n    this.loadDatabase(options.onload || function (err) {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\n\nutil.inherits(Datastore, require('events').EventEmitter);\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\n\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({\n    this: this.persistence,\n    fn: this.persistence.loadDatabase,\n    arguments: arguments\n  }, true);\n};\n/**\n * Get an array of all the data in the database\n */\n\n\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n/**\n * Reset all currently defined indexes\n */\n\n\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err,\n      callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n\n  if (this.indexes[options.fieldName]) {\n    return callback(null);\n  }\n\n  this.indexes[options.fieldName] = new Index(options);\n\n  if (options.expireAfterSeconds !== undefined) {\n    this.ttlIndexes[options.fieldName] = options.expireAfterSeconds;\n  } // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  } // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n\n\n  this.persistence.persistNewState([{\n    $$indexCreated: options\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null);\n  });\n};\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n  this.persistence.persistNewState([{\n    $$indexRemoved: fieldName\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null);\n  });\n};\n/**\n * Add one or several document(s) to all indexes\n */\n\n\nDatastore.prototype.addToIndexes = function (doc) {\n  var i,\n      failingIndex,\n      error,\n      keys = Object.keys(this.indexes);\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  } // If an error happened, we need to rollback the insert on all other indexes\n\n\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Remove one or several document(s) from all indexes\n */\n\n\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\n\n\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i,\n      failingIndex,\n      error,\n      keys = Object.keys(this.indexes);\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  } // If an error happened, we need to rollback the update on all other indexes\n\n\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\n\n\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes),\n      self = this,\n      usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([// STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    } // For a $in match\n\n\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    } // For a comparison match\n\n\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    } // By default, return all the DB data\n\n\n    return cb(null, self.getAllData());\n  } // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) {\n      return callback(null, docs);\n    }\n\n    var expiredDocsIds = [],\n        validDocs = [],\n        ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n\n      if (valid) {\n        validDocs.push(doc);\n      } else {\n        expiredDocsIds.push(doc._id);\n      }\n    });\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({\n        _id: _id\n      }, {}, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\n\n\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {},\n      preparedDoc;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc);\n\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n/**\n * Create a new _id that's not already in use\n */\n\n\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16); // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n\n  return tentativeId;\n};\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\n\n\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc,\n      self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) {\n      preparedDoc.push(self.prepareDocumentForInsertion(doc));\n    });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n\n    if (preparedDoc._id === undefined) {\n      preparedDoc._id = this.createNewId();\n    }\n\n    var now = new Date();\n\n    if (this.timestampData && preparedDoc.createdAt === undefined) {\n      preparedDoc.createdAt = now;\n    }\n\n    if (this.timestampData && preparedDoc.updatedAt === undefined) {\n      preparedDoc.updatedAt = now;\n    }\n\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\n\n\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\n\n\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({\n    this: this,\n    fn: this._insert,\n    arguments: arguments\n  });\n};\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\n\n\nDatastore.prototype.count = function (query, callback) {\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\n\n\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {}; // callback is undefined, will return a cursor\n\n      break;\n\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n\n\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    var res = [],\n        i;\n\n    if (err) {\n      return callback(err);\n    }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n\n    return callback(null, res);\n  });\n  cursor.projection(projection);\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\n\n\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {}; // callback is undefined, will return a cursor\n\n      break;\n\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n\n\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n  cursor.projection(projection).limit(1);\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\n\n\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback,\n      self = this,\n      numReplaced = 0,\n      multi,\n      upsert,\n      i;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  callback = cb || function () {};\n\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n  async.waterfall([function (cb) {\n    // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) {\n      return cb();\n    } // Need to use an internal function not tied to the executor to avoid deadlock\n\n\n    var cursor = new Cursor(self, query);\n\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery); // updateQuery is a simple object with no modifier, use it as the document to insert\n\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) {\n            return callback(err);\n          }\n\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }, function () {\n    // Perform the update\n    var modifiedDoc,\n        modifications = [],\n        createdAt;\n    self.getCandidates(query, function (err, candidates) {\n      if (err) {\n        return callback(err);\n      } // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n\n\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n\n            if (self.timestampData) {\n              createdAt = candidates[i].createdAt;\n            }\n\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n\n            modifications.push({\n              oldDoc: candidates[i],\n              newDoc: modifiedDoc\n            });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      } // Change the docs in memory\n\n\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      } // Update the datafile\n\n\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) {\n            updatedDocsDC.push(model.deepCopy(doc));\n          });\n\n          if (!multi) {\n            updatedDocsDC = updatedDocsDC[0];\n          }\n\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({\n    this: this,\n    fn: this._update,\n    arguments: arguments\n  });\n};\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\n\n\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback,\n      self = this,\n      numRemoved = 0,\n      removedDocs = [],\n      multi;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  callback = cb || function () {};\n\n  multi = options.multi !== undefined ? options.multi : false;\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({\n            $$deleted: true,\n            _id: d._id\n          });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) {\n      return callback(err);\n    }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({\n    this: this,\n    fn: this._remove,\n    arguments: arguments\n  });\n};\n\nmodule.exports = Datastore;","map":{"version":3,"names":["customUtils","require","model","async","Executor","Index","util","_","Persistence","Cursor","Datastore","options","filename","inMemoryOnly","autoload","timestampData","length","compareStrings","persistence","db","nodeWebkitAppName","afterSerialization","beforeDeserialization","corruptAlertThreshold","executor","ready","indexes","_id","fieldName","unique","ttlIndexes","loadDatabase","onload","err","inherits","EventEmitter","prototype","push","this","fn","arguments","getAllData","getAll","resetIndexes","newData","self","Object","keys","forEach","i","reset","ensureIndex","cb","callback","Error","missingFieldName","expireAfterSeconds","undefined","insert","e","persistNewState","$$indexCreated","removeIndex","$$indexRemoved","addToIndexes","doc","failingIndex","error","remove","removeFromIndexes","updateIndexes","oldDoc","newDoc","update","revertUpdate","getCandidates","query","dontExpireStaleDocs","indexNames","usableQueryKeys","waterfall","k","isDate","intersection","getMatching","hasOwnProperty","$in","getBetweenBounds","docs","expiredDocsIds","validDocs","ttlIndexesFieldNames","valid","Date","now","getTime","eachSeries","_remove","_insert","preparedDoc","prepareDocumentForInsertion","_insertInCache","isArray","deepCopy","createNewId","tentativeId","uid","createdAt","updatedAt","checkObject","_insertMultipleDocsInCache","preparedDocs","failingI","count","cursor","exec","find","projection","res","findOne","limit","_update","updateQuery","numReplaced","multi","upsert","_exec","toBeInserted","modify","modifiedDoc","modifications","candidates","match","updatedDocs","pluck","returnUpdatedDocs","updatedDocsDC","numRemoved","removedDocs","d","$$deleted","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/nedb/lib/datastore.js"],"sourcesContent":["var customUtils = require('./customUtils')\n  , model = require('./model')\n  , async = require('async')\n  , Executor = require('./executor')\n  , Index = require('./indexes')\n  , util = require('util')\n  , _ = require('underscore')\n  , Persistence = require('./persistence')\n  , Cursor = require('./cursor')\n  ;\n\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore (options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false;   // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName\n                                      , afterSerialization: options.afterSerialization\n                                      , beforeDeserialization: options.beforeDeserialization\n                                      , corruptAlertThreshold: options.corruptAlertThreshold\n                                      });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) { this.executor.ready = true; }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) { this.loadDatabase(options.onload || function (err) {\n    if (err) { throw err; }\n  }); }\n}\n\nutil.inherits(Datastore, require('events').EventEmitter);\n\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\n};\n\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err\n    , callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) { return callback(null); }\n\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes)\n    , self = this\n    , usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) { return callback(null, docs); }\n\n    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000)Â {\n          valid = false;\n        }\n      });\n      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }\n    });\n\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({ _id: _id }, {}, function (err) {\n        if (err) { return callback(err); }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {}\n    , preparedDoc\n    ;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc)\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) { return callback(err); }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc, self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\n};\n\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function(query, callback) {\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    var res = [], i;\n\n    if (err) { return callback(err); }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback\n    , self = this\n    , numReplaced = 0\n    , multi, upsert\n    , i\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n\n  async.waterfall([\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) { return cb(); }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) { return callback(err); }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) { return callback(err); }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }\n  , function () {   // Perform the update\n    var modifiedDoc , modifications = [], createdAt;\n\n    self.getCandidates(query, function (err, candidates) {\n      if (err) { return callback(err); }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) { createdAt = candidates[i].createdAt; }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) { return callback(err); }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });\n          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\n};\n\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback\n    , self = this, numRemoved = 0, removedDocs = [], multi\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({ $$deleted: true, _id: d._id });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) { return callback(err); }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) { return callback(err); }\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\n};\n\n\n\nmodule.exports = Datastore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}