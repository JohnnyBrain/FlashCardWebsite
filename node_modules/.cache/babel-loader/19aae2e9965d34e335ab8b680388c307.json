{"ast":null,"code":"const idRegex = /^[a-z0-9-]{1,32}$/;\nconst nameRegex = /^[a-z0-9-]{1,32}$/;\nconst valueRegex = /^[a-zA-Z0-9/+.-]+$/;\nconst b64Regex = /^([a-zA-Z0-9/+.-]+|)$/;\nconst decimalRegex = /^((-)?[1-9]\\d*|0)$/;\nconst versionRegex = /^v=(\\d+)$/;\n\nfunction objToKeyVal(obj) {\n  return objectKeys(obj).map(k => [k, obj[k]].join('=')).join(',');\n}\n\nfunction keyValtoObj(str) {\n  const obj = {};\n  str.split(',').forEach(ps => {\n    const pss = ps.split('=');\n\n    if (pss.length < 2) {\n      throw new TypeError(`params must be in the format name=value`);\n    }\n\n    obj[pss.shift()] = pss.join('=');\n  });\n  return obj;\n}\n\nfunction objectKeys(object) {\n  /* istanbul ignore next */\n  return Object.keys(object);\n}\n\nfunction objectValues(object) {\n  /* istanbul ignore next */\n  if (typeof Object.values === 'function') return Object.values(object);\n  /* istanbul ignore next */\n\n  return objectKeys(object).map(k => object[k]);\n}\n/**\n * Generates a PHC string using the data provided.\n * @param  {Object} opts Object that holds the data needed to generate the PHC\n * string.\n * @param  {string} opts.id Symbolic name for the function.\n * @param  {Number} [opts.version] The version of the function.\n * @param  {Object} [opts.params] Parameters of the function.\n * @param  {Buffer} [opts.salt] The salt as a binary buffer.\n * @param  {Buffer} [opts.hash] The hash as a binary buffer.\n * @return {string} The hash string adhering to the PHC format.\n */\n\n\nfunction serialize(opts) {\n  const fields = [''];\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError('opts must be an object');\n  } // Identifier Validation\n\n\n  if (typeof opts.id !== 'string') {\n    throw new TypeError('id must be a string');\n  }\n\n  if (!idRegex.test(opts.id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  fields.push(opts.id);\n\n  if (typeof opts.version !== 'undefined') {\n    if (typeof opts.version !== 'number' || opts.version < 0 || !Number.isInteger(opts.version)) {\n      throw new TypeError('version must be a positive integer number');\n    }\n\n    fields.push(`v=${opts.version}`);\n  } // Parameters Validation\n\n\n  if (typeof opts.params !== 'undefined') {\n    if (typeof opts.params !== 'object' || opts.params === null) {\n      throw new TypeError('params must be an object');\n    }\n\n    const pk = objectKeys(opts.params);\n\n    if (!pk.every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    } // Convert Numbers into Numeric Strings and Buffers into B64 encoded strings.\n\n\n    pk.forEach(k => {\n      if (typeof opts.params[k] === 'number') {\n        opts.params[k] = opts.params[k].toString();\n      } else if (Buffer.isBuffer(opts.params[k])) {\n        opts.params[k] = opts.params[k].toString('base64').split('=')[0];\n      }\n    });\n    const pv = objectValues(opts.params);\n\n    if (!pv.every(v => typeof v === 'string')) {\n      throw new TypeError('params values must be strings');\n    }\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const strpar = objToKeyVal(opts.params);\n    fields.push(strpar);\n  }\n\n  if (typeof opts.salt !== 'undefined') {\n    // Salt Validation\n    if (!Buffer.isBuffer(opts.salt)) {\n      throw new TypeError('salt must be a Buffer');\n    }\n\n    fields.push(opts.salt.toString('base64').split('=')[0]);\n\n    if (typeof opts.hash !== 'undefined') {\n      // Hash Validation\n      if (!Buffer.isBuffer(opts.hash)) {\n        throw new TypeError('hash must be a Buffer');\n      }\n\n      fields.push(opts.hash.toString('base64').split('=')[0]);\n    }\n  } // Create the PHC formatted string\n\n\n  const phcstr = fields.join('$');\n  return phcstr;\n}\n/**\n * Parses data from a PHC string.\n * @param  {string} phcstr A PHC string to parse.\n * @return {Object} The object containing the data parsed from the PHC string.\n */\n\n\nfunction deserialize(phcstr) {\n  if (typeof phcstr !== 'string' || phcstr === '') {\n    throw new TypeError('pchstr must be a non-empty string');\n  }\n\n  if (phcstr[0] !== '$') {\n    throw new TypeError('pchstr must contain a $ as first char');\n  }\n\n  const fields = phcstr.split('$'); // Remove first empty $\n\n  fields.shift(); // Parse Fields\n\n  let maxf = 5;\n  if (!versionRegex.test(fields[1])) maxf--;\n\n  if (fields.length > maxf) {\n    throw new TypeError(`pchstr contains too many fileds: ${fields.length}/${maxf}`);\n  } // Parse Identifier\n\n\n  const id = fields.shift();\n\n  if (!idRegex.test(id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  let version; // Parse Version\n\n  if (versionRegex.test(fields[0])) {\n    version = parseInt(fields.shift().match(versionRegex)[1], 10);\n  }\n\n  let hash;\n  let salt;\n\n  if (b64Regex.test(fields[fields.length - 1])) {\n    if (fields.length > 1 && b64Regex.test(fields[fields.length - 2])) {\n      // Parse Hash\n      hash = Buffer.from(fields.pop(), 'base64'); // Parse Salt\n\n      salt = Buffer.from(fields.pop(), 'base64');\n    } else {\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    }\n  } // Parse Parameters\n\n\n  let params;\n\n  if (fields.length > 0) {\n    const parstr = fields.pop();\n    params = keyValtoObj(parstr);\n\n    if (!objectKeys(params).every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    const pv = objectValues(params);\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const pk = objectKeys(params); // Convert Decimal Strings into Numbers\n\n    pk.forEach(k => {\n      params[k] = decimalRegex.test(params[k]) ? parseInt(params[k], 10) : params[k];\n    });\n  }\n\n  if (fields.length > 0) {\n    throw new TypeError(`pchstr contains unrecognized fileds: ${fields}`);\n  } // Build the output object\n\n\n  const phcobj = {\n    id\n  };\n  if (version) phcobj.version = version;\n  if (params) phcobj.params = params;\n  if (salt) phcobj.salt = salt;\n  if (hash) phcobj.hash = hash;\n  return phcobj;\n}\n\nmodule.exports = {\n  serialize,\n  deserialize\n};","map":{"version":3,"names":["idRegex","nameRegex","valueRegex","b64Regex","decimalRegex","versionRegex","objToKeyVal","obj","objectKeys","map","k","join","keyValtoObj","str","split","forEach","ps","pss","length","TypeError","shift","object","Object","keys","objectValues","values","serialize","opts","fields","id","test","push","version","Number","isInteger","params","pk","every","p","toString","Buffer","isBuffer","pv","v","strpar","salt","hash","phcstr","deserialize","maxf","parseInt","match","from","pop","parstr","phcobj","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/@phc/format/index.js"],"sourcesContent":["const idRegex = /^[a-z0-9-]{1,32}$/;\nconst nameRegex = /^[a-z0-9-]{1,32}$/;\nconst valueRegex = /^[a-zA-Z0-9/+.-]+$/;\nconst b64Regex = /^([a-zA-Z0-9/+.-]+|)$/;\nconst decimalRegex = /^((-)?[1-9]\\d*|0)$/;\nconst versionRegex = /^v=(\\d+)$/;\n\nfunction objToKeyVal(obj) {\n  return objectKeys(obj)\n    .map(k => [k, obj[k]].join('='))\n    .join(',');\n}\n\nfunction keyValtoObj(str) {\n  const obj = {};\n  str.split(',').forEach(ps => {\n    const pss = ps.split('=');\n    if (pss.length < 2) {\n      throw new TypeError(`params must be in the format name=value`);\n    }\n\n    obj[pss.shift()] = pss.join('=');\n  });\n  return obj;\n}\n\nfunction objectKeys(object) {\n  /* istanbul ignore next */\n  return Object.keys(object);\n}\n\nfunction objectValues(object) {\n  /* istanbul ignore next */\n  if (typeof Object.values === 'function') return Object.values(object);\n  /* istanbul ignore next */\n  return objectKeys(object).map(k => object[k]);\n}\n\n/**\n * Generates a PHC string using the data provided.\n * @param  {Object} opts Object that holds the data needed to generate the PHC\n * string.\n * @param  {string} opts.id Symbolic name for the function.\n * @param  {Number} [opts.version] The version of the function.\n * @param  {Object} [opts.params] Parameters of the function.\n * @param  {Buffer} [opts.salt] The salt as a binary buffer.\n * @param  {Buffer} [opts.hash] The hash as a binary buffer.\n * @return {string} The hash string adhering to the PHC format.\n */\nfunction serialize(opts) {\n  const fields = [''];\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError('opts must be an object');\n  }\n\n  // Identifier Validation\n  if (typeof opts.id !== 'string') {\n    throw new TypeError('id must be a string');\n  }\n\n  if (!idRegex.test(opts.id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  fields.push(opts.id);\n\n  if (typeof opts.version !== 'undefined') {\n    if (\n      typeof opts.version !== 'number' ||\n      opts.version < 0 ||\n      !Number.isInteger(opts.version)\n    ) {\n      throw new TypeError('version must be a positive integer number');\n    }\n\n    fields.push(`v=${opts.version}`);\n  }\n\n  // Parameters Validation\n  if (typeof opts.params !== 'undefined') {\n    if (typeof opts.params !== 'object' || opts.params === null) {\n      throw new TypeError('params must be an object');\n    }\n\n    const pk = objectKeys(opts.params);\n    if (!pk.every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    // Convert Numbers into Numeric Strings and Buffers into B64 encoded strings.\n    pk.forEach(k => {\n      if (typeof opts.params[k] === 'number') {\n        opts.params[k] = opts.params[k].toString();\n      } else if (Buffer.isBuffer(opts.params[k])) {\n        opts.params[k] = opts.params[k].toString('base64').split('=')[0];\n      }\n    });\n    const pv = objectValues(opts.params);\n    if (!pv.every(v => typeof v === 'string')) {\n      throw new TypeError('params values must be strings');\n    }\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const strpar = objToKeyVal(opts.params);\n    fields.push(strpar);\n  }\n\n  if (typeof opts.salt !== 'undefined') {\n    // Salt Validation\n    if (!Buffer.isBuffer(opts.salt)) {\n      throw new TypeError('salt must be a Buffer');\n    }\n\n    fields.push(opts.salt.toString('base64').split('=')[0]);\n\n    if (typeof opts.hash !== 'undefined') {\n      // Hash Validation\n      if (!Buffer.isBuffer(opts.hash)) {\n        throw new TypeError('hash must be a Buffer');\n      }\n\n      fields.push(opts.hash.toString('base64').split('=')[0]);\n    }\n  }\n\n  // Create the PHC formatted string\n  const phcstr = fields.join('$');\n\n  return phcstr;\n}\n\n/**\n * Parses data from a PHC string.\n * @param  {string} phcstr A PHC string to parse.\n * @return {Object} The object containing the data parsed from the PHC string.\n */\nfunction deserialize(phcstr) {\n  if (typeof phcstr !== 'string' || phcstr === '') {\n    throw new TypeError('pchstr must be a non-empty string');\n  }\n\n  if (phcstr[0] !== '$') {\n    throw new TypeError('pchstr must contain a $ as first char');\n  }\n\n  const fields = phcstr.split('$');\n  // Remove first empty $\n  fields.shift();\n\n  // Parse Fields\n  let maxf = 5;\n  if (!versionRegex.test(fields[1])) maxf--;\n  if (fields.length > maxf) {\n    throw new TypeError(\n      `pchstr contains too many fileds: ${fields.length}/${maxf}`\n    );\n  }\n\n  // Parse Identifier\n  const id = fields.shift();\n  if (!idRegex.test(id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  let version;\n  // Parse Version\n  if (versionRegex.test(fields[0])) {\n    version = parseInt(fields.shift().match(versionRegex)[1], 10);\n  }\n\n  let hash;\n  let salt;\n  if (b64Regex.test(fields[fields.length - 1])) {\n    if (fields.length > 1 && b64Regex.test(fields[fields.length - 2])) {\n      // Parse Hash\n      hash = Buffer.from(fields.pop(), 'base64');\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    } else {\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    }\n  }\n\n  // Parse Parameters\n  let params;\n  if (fields.length > 0) {\n    const parstr = fields.pop();\n    params = keyValtoObj(parstr);\n    if (!objectKeys(params).every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    const pv = objectValues(params);\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const pk = objectKeys(params);\n    // Convert Decimal Strings into Numbers\n    pk.forEach(k => {\n      params[k] = decimalRegex.test(params[k])\n        ? parseInt(params[k], 10)\n        : params[k];\n    });\n  }\n\n  if (fields.length > 0) {\n    throw new TypeError(`pchstr contains unrecognized fileds: ${fields}`);\n  }\n\n  // Build the output object\n  const phcobj = {id};\n  if (version) phcobj.version = version;\n  if (params) phcobj.params = params;\n  if (salt) phcobj.salt = salt;\n  if (hash) phcobj.hash = hash;\n\n  return phcobj;\n}\n\nmodule.exports = {\n  serialize,\n  deserialize\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}