{"ast":null,"code":"/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction BinarySearchTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n} // ================================\n// Methods used to test the tree\n// ================================\n\n/**\n * Get the descendant with max key\n */\n\n\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the maximum key\n */\n\n\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n/**\n * Get the descendant with min key\n */\n\n\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the minimum key\n */\n\n\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\n\n\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  test(this.key, this.data);\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(test);\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(test);\n  }\n};\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\n\n\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n/**\n * Check that all pointers are coherent in this tree\n */\n\n\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.right.checkInternalPointers();\n  }\n};\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\n\n\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n\n  if (this.parent) {\n    throw new Error(\"The root shouldn't have a parent\");\n  }\n};\n/**\n * Get number of keys inserted\n */\n\n\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) {\n    return 0;\n  }\n\n  res = 1;\n\n  if (this.left) {\n    res += this.left.getNumberOfKeys();\n  }\n\n  if (this.right) {\n    res += this.right.getNumberOfKeys();\n  }\n\n  return res;\n}; // ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\n\n\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n  return new this.constructor(options);\n};\n/**\n * Create the left child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n  return leftChild;\n};\n/**\n * Create the right child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n  return rightChild;\n};\n/**\n * Insert a new element\n */\n\n\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  } // Same key as root\n\n\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({\n        key: key,\n        value: value\n      });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n};\n/**\n * Search for all data corresponding to a key\n */\n\n\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  }\n\n  if (this.compareKeys(this.key, key) === 0) {\n    return this.data;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\n\n\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gte) >= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$gt) > 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$gte) >= 0;\n    };\n  }\n};\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\n\n\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lte) <= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$lt) < 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$lte) <= 0;\n    };\n  }\n}; // Append all elements in toAppend to array\n\n\nfunction append(array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\n\n\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  } // Empty tree\n\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) {\n    append(res, this.left.betweenBounds(query, lbm, ubm));\n  }\n\n  if (lbm(this.key) && ubm(this.key)) {\n    append(res, this.data);\n  }\n\n  if (ubm(this.key) && this.right) {\n    append(res, this.right.betweenBounds(query, lbm, ubm));\n  }\n\n  return res;\n};\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) {\n    return false;\n  } // The leaf is itself a root\n\n\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) {\n    child = this.left;\n  }\n\n  if (!this.left && this.right) {\n    child = this.right;\n  }\n\n  if (!child) {\n    return false;\n  } // Root\n\n\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n    this.left = null;\n\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      this.left.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) {\n      this.right.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) {\n    return;\n  } // Delete only a value\n\n\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    self.data = newData;\n    return;\n  } // Delete the whole node\n\n\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  } // We are in the case where the node to delete has two children\n\n\n  if (Math.random() >= 0.5) {\n    // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.left = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.right = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n};\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\n\n\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) {\n    this.left.executeOnEveryNode(fn);\n  }\n\n  fn(this);\n\n  if (this.right) {\n    this.right.executeOnEveryNode(fn);\n  }\n};\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\n\n\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n  console.log(spacing + \"* \" + this.key);\n\n  if (printData) {\n    console.log(spacing + \"* \" + this.data);\n  }\n\n  if (!this.left && !this.right) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n}; // Interface\n\n\nmodule.exports = BinarySearchTree;","map":{"version":3,"names":["customUtils","require","BinarySearchTree","options","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","prototype","getMaxKeyDescendant","getMaxKey","getMinKeyDescendant","getMinKey","checkAllNodesFullfillCondition","test","checkNodeOrdering","self","k","Error","checkInternalPointers","checkIsBST","getNumberOfKeys","res","createSimilar","constructor","createLeftChild","leftChild","createRightChild","rightChild","insert","push","err","errorType","search","getLowerBoundMatcher","query","$gte","$gt","getUpperBoundMatcher","$lte","$lt","append","array","toAppend","i","length","betweenBounds","lbm","ubm","deleteIfLeaf","deleteIfOnlyOneChild","child","delete","newData","replaceWith","forEach","d","Math","random","executeOnEveryNode","fn","prettyPrint","printData","spacing","console","log","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/binary-search-tree/lib/bst.js"],"sourcesContent":["/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw new Error(\"The root shouldn't have a parent\"); }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}