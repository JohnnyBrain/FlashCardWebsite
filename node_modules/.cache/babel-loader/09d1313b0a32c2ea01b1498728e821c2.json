{"ast":null,"code":"/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\nvar storage = require('./storage'),\n    path = require('path'),\n    model = require('./model'),\n    async = require('async'),\n    customUtils = require('./customUtils'),\n    Index = require('./indexes');\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\n\n\nfunction Persistence(options) {\n  var i, j, randomString;\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  } // After serialization and before deserialization hooks with some basic sanity checks\n\n\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  this.afterSerialization = options.afterSerialization || function (s) {\n    return s;\n  };\n\n  this.beforeDeserialization = options.beforeDeserialization || function (s) {\n    return s;\n  };\n\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  } // For NW apps, store data in the same directory where NW stores application data\n\n\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n}\n\n;\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\n\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {};\n\n  storage.mkdirp(dir, function (err) {\n    return callback(err);\n  });\n};\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\n\n\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data folder\");\n      }\n\n      home = path.join(home, appName);\n      break;\n\n    case 'darwin':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n\n    case 'linux':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, '.config', appName);\n      break;\n\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n};\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {},\n      toPersist = '',\n      self = this;\n\n  if (this.inMemoryOnly) {\n    return callback(null);\n  }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {\n      // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({\n        $$indexCreated: {\n          fieldName: fieldName,\n          unique: self.db.indexes[fieldName].unique,\n          sparse: self.db.indexes[fieldName].sparse\n        }\n      })) + '\\n';\n    }\n  });\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n/**\n * Queue a rewrite of the datafile\n */\n\n\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this.persistCachedDatabase,\n    arguments: []\n  });\n};\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\n\n\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this,\n      minInterval = 5000,\n      realInterval = Math.max(interval || 0, minInterval);\n  this.stopAutocompaction();\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\n\n\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) {\n    clearInterval(this.autocompactionIntervalId);\n  }\n};\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\n\n\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this,\n      toPersist = '',\n      callback = cb || function () {}; // In-memory only datastore\n\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) {\n    return callback(null);\n  }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\n\n\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n'),\n      dataById = {},\n      tdata = [],\n      i,\n      indexes = {},\n      corruptItems = -1 // Last line of every data file is usually blank so not really corrupt\n  ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  } // A bit lenient on corruption\n\n\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n  return {\n    data: tdata,\n    indexes: indexes\n  };\n};\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {},\n      self = this;\n\n  self.db.resetIndexes(); // In-memory only datastore\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  async.waterfall([function (cb) {\n    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n      storage.ensureDatafileIntegrity(self.filename, function (err) {\n        storage.readFile(self.filename, 'utf8', function (err, rawData) {\n          if (err) {\n            return cb(err);\n          }\n\n          try {\n            var treatedData = self.treatRawData(rawData);\n          } catch (e) {\n            return cb(e);\n          } // Recreate all indexes in the datafile\n\n\n          Object.keys(treatedData.indexes).forEach(function (key) {\n            self.db.indexes[key] = new Index(treatedData.indexes[key]);\n          }); // Fill cached database (i.e. all indexes) with data\n\n          try {\n            self.db.resetIndexes(treatedData.data);\n          } catch (e) {\n            self.db.resetIndexes(); // Rollback any index which didn't fail\n\n            return cb(e);\n          }\n\n          self.db.persistence.persistCachedDatabase(cb);\n        });\n      });\n    });\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.executor.processBuffer();\n    return callback(null);\n  });\n}; // Interface\n\n\nmodule.exports = Persistence;","map":{"version":3,"names":["storage","require","path","model","async","customUtils","Index","Persistence","options","i","j","randomString","db","inMemoryOnly","filename","corruptAlertThreshold","undefined","charAt","length","Error","afterSerialization","beforeDeserialization","s","uid","nodeWebkitAppName","console","log","getNWAppFilename","ensureDirectoryExists","dir","cb","callback","mkdirp","err","appName","relativeFilename","home","process","platform","env","LOCALAPPDATA","APPDATA","join","HOME","prototype","persistCachedDatabase","toPersist","self","getAllData","forEach","doc","serialize","Object","keys","indexes","fieldName","$$indexCreated","unique","sparse","crashSafeWriteFile","emit","compactDatafile","executor","push","this","fn","arguments","setAutocompactionInterval","interval","minInterval","realInterval","Math","max","stopAutocompaction","autocompactionIntervalId","setInterval","clearInterval","persistNewState","newDocs","appendFile","treatRawData","rawData","data","split","dataById","tdata","corruptItems","deserialize","_id","$$deleted","$$indexRemoved","e","floor","k","loadDatabase","resetIndexes","waterfall","dirname","ensureDatafileIntegrity","readFile","treatedData","key","persistence","processBuffer","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/nedb/lib/persistence.js"],"sourcesContent":["/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = require('./storage')\n  , path = require('path')\n  , model = require('./model')\n  , async = require('async')\n  , customUtils = require('./customUtils')\n  , Index = require('./indexes')\n  ;\n\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence (options) {\n  var i, j, randomString;\n\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) { return s; };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n};\n\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {}\n    ;\n\n  storage.mkdirp(dir, function (err) { return callback(err); });\n};\n\n\n\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) { throw new Error(\"Couldn't find the base application data folder\"); }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n}\n\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {}\n    , toPersist = ''\n    , self = this\n    ;\n\n  if (this.inMemoryOnly) { return callback(null); }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {   // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\\n';\n    }\n  });\n\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) { return callback(err); }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });\n};\n\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this\n    , minInterval = 5000\n    , realInterval = Math.max(interval || 0, minInterval)\n    ;\n\n  this.stopAutocompaction();\n\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }\n};\n\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this\n    , toPersist = ''\n    , callback = cb || function () {}\n    ;\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) { return callback(null); }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n')\n    , dataById = {}\n    , tdata = []\n    , i\n    , indexes = {}\n    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt\n    ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n\n  return { data: tdata, indexes: indexes };\n};\n\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {}\n    , self = this\n    ;\n\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  async.waterfall([\n    function (cb) {\n      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n        storage.ensureDatafileIntegrity(self.filename, function (err) {\n          storage.readFile(self.filename, 'utf8', function (err, rawData) {\n            if (err) { return cb(err); }\n\n            try {\n              var treatedData = self.treatRawData(rawData);\n            } catch (e) {\n              return cb(e);\n            }\n\n            // Recreate all indexes in the datafile\n            Object.keys(treatedData.indexes).forEach(function (key) {\n              self.db.indexes[key] = new Index(treatedData.indexes[key]);\n            });\n\n            // Fill cached database (i.e. all indexes) with data\n            try {\n              self.db.resetIndexes(treatedData.data);\n            } catch (e) {\n              self.db.resetIndexes();   // Rollback any index which didn't fail\n              return cb(e);\n            }\n\n            self.db.persistence.persistCachedDatabase(cb);\n          });\n        });\n      });\n    }\n  ], function (err) {\n       if (err) { return callback(err); }\n\n       self.db.executor.processBuffer();\n       return callback(null);\n     });\n};\n\n\n// Interface\nmodule.exports = Persistence;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}