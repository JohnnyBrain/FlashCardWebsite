{"ast":null,"code":"var BinarySearchTree = require('binary-search-tree').AVLTree,\n    model = require('./model'),\n    _ = require('underscore'),\n    util = require('util');\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\n\n\nfunction checkValueEquality(a, b) {\n  return a === b;\n}\n/**\n * Type-aware projection\n */\n\n\nfunction projectForUnique(elt) {\n  if (elt === null) {\n    return '$null';\n  }\n\n  if (typeof elt === 'string') {\n    return '$string' + elt;\n  }\n\n  if (typeof elt === 'boolean') {\n    return '$boolean' + elt;\n  }\n\n  if (typeof elt === 'number') {\n    return '$number' + elt;\n  }\n\n  if (util.isArray(elt)) {\n    return '$date' + elt.getTime();\n  }\n\n  return elt; // Arrays and objects, will check for pointer equality\n}\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\n\n\nfunction Index(options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n  this.treeOptions = {\n    unique: this.unique,\n    compareKeys: model.compareThings,\n    checkValueEquality: checkValueEquality\n  };\n  this.reset(); // No data in the beginning\n}\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\n\n\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) {\n    this.insert(newData);\n  }\n};\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\n\n\nIndex.prototype.insert = function (doc) {\n  var key,\n      self = this,\n      keys,\n      i,\n      failingI,\n      error;\n\n  if (util.isArray(doc)) {\n    this.insertMultipleDocs(doc);\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName); // We don't index documents that don't contain the field if the index is sparse\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\n\n\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\n\n\nIndex.prototype.remove = function (doc) {\n  var key,\n      self = this;\n\n  if (util.isArray(doc)) {\n    doc.forEach(function (d) {\n      self.remove(d);\n    });\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\n\n\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) {\n    this.updateMultipleDocs(oldDoc);\n    return;\n  }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\n\n\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  } // If an error was raised, roll back changes in the inverse order\n\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Revert an update\n */\n\n\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({\n        oldDoc: pair.newDoc,\n        newDoc: pair.oldDoc\n      });\n    });\n    this.update(revert);\n  }\n};\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {},\n        res = [];\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n    return res;\n  }\n};\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getAll = function () {\n  var res = [];\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n  return res;\n}; // Interface\n\n\nmodule.exports = Index;","map":{"version":3,"names":["BinarySearchTree","require","AVLTree","model","_","util","checkValueEquality","a","b","projectForUnique","elt","isArray","getTime","Index","options","fieldName","unique","sparse","treeOptions","compareKeys","compareThings","reset","prototype","newData","tree","insert","doc","key","self","keys","i","failingI","error","insertMultipleDocs","getDotValue","undefined","uniq","length","e","delete","docs","remove","forEach","d","_key","update","oldDoc","newDoc","updateMultipleDocs","pairs","revertUpdate","revert","pair","push","getMatching","value","search","_res","res","v","_id","Object","getBetweenBounds","query","betweenBounds","getAll","executeOnEveryNode","node","data","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/nedb/lib/indexes.js"],"sourcesContent":["var BinarySearchTree = require('binary-search-tree').AVLTree\n  , model = require('./model')\n  , _ = require('underscore')\n  , util = require('util')\n  ;\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality (a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique (elt) {\n  if (elt === null) { return '$null'; }\n  if (typeof elt === 'string') { return '$string' + elt; }\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\n  if (typeof elt === 'number') { return '$number' + elt; }\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\n\n  return elt;   // Arrays and objects, will check for pointer equality\n}\n\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index (options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\n\n  this.reset();   // No data in the beginning\n}\n\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) { this.insert(newData); }\n};\n\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key, self = this\n    , keys, i, failingI, error\n    ;\n\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key, self = this;\n\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\n    });\n    this.update(revert);\n  }\n};\n\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {}, res = [];\n\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n\n    return res;\n  }\n};\n\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n\n  return res;\n};\n\n\n\n\n// Interface\nmodule.exports = Index;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}