{"ast":null,"code":"\"use strict\";\n\nconst assert = require(\"assert\");\n\nconst {\n  randomBytes,\n  timingSafeEqual\n} = require(\"crypto\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst {\n  hash: _hash\n} = require(\"./lib/binding/napi-v3/argon2.node\");\n\nconst {\n  deserialize,\n  serialize\n} = require(\"@phc/format\");\n\nconst types = Object.freeze({\n  argon2d: 0,\n  argon2i: 1,\n  argon2id: 2\n});\nconst defaults = Object.freeze({\n  hashLength: 32,\n  saltLength: 16,\n  timeCost: 3,\n  memoryCost: 1 << 12,\n  parallelism: 1,\n  type: types.argon2id,\n  version: 0x13\n});\nconst limits = Object.freeze({\n  hashLength: {\n    min: 4,\n    max: 2 ** 32 - 1\n  },\n  memoryCost: {\n    min: 1 << 10,\n    max: 2 ** 32 - 1\n  },\n  timeCost: {\n    min: 2,\n    max: 2 ** 32 - 1\n  },\n  parallelism: {\n    min: 1,\n    max: 2 ** 24 - 1\n  }\n});\nconst names = Object.freeze({\n  [types.argon2d]: \"argon2d\",\n  [types.argon2i]: \"argon2i\",\n  [types.argon2id]: \"argon2id\"\n});\nconst bindingsHash = promisify(_hash);\nconst generateSalt = promisify(randomBytes);\n\nconst assertLimits = options => _ref => {\n  let [key, {\n    max,\n    min\n  }] = _ref;\n  const value = options[key];\n  assert(min <= value && value <= max, `Invalid ${key}, must be between ${min} and ${max}.`);\n};\n\nconst hash = async function (plain) {\n  let {\n    raw,\n    salt,\n    ...options\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = { ...defaults,\n    ...options\n  };\n  Object.entries(limits).forEach(assertLimits(options));\n  salt = salt || (await generateSalt(options.saltLength));\n  const hash = await bindingsHash(Buffer.from(plain), salt, options);\n\n  if (raw) {\n    return hash;\n  }\n\n  const {\n    type,\n    version,\n    memoryCost: m,\n    timeCost: t,\n    parallelism: p,\n    associatedData: data\n  } = options;\n  return serialize({\n    id: names[type],\n    version,\n    params: {\n      m,\n      t,\n      p,\n      ...(data ? {\n        data\n      } : {})\n    },\n    salt,\n    hash\n  });\n};\n\nconst needsRehash = (digest, options) => {\n  const {\n    memoryCost,\n    timeCost,\n    version\n  } = { ...defaults,\n    ...options\n  };\n  const {\n    version: v,\n    params: {\n      m,\n      t\n    }\n  } = deserialize(digest);\n  return +v !== +version || +m !== +memoryCost || +t !== +timeCost;\n};\n\nconst verify = async (digest, plain, options) => {\n  const obj = deserialize(digest); // Only these have the \"params\" key, so if the password was encoded\n  // using any other method, the destructuring throws an error\n\n  if (!(obj.id in types)) {\n    return false;\n  }\n\n  const {\n    id,\n    version = 0x10,\n    params: {\n      m,\n      t,\n      p,\n      data\n    },\n    salt,\n    hash\n  } = obj;\n  return timingSafeEqual(await bindingsHash(Buffer.from(plain), salt, { ...options,\n    type: types[id],\n    version: +version,\n    hashLength: hash.length,\n    memoryCost: +m,\n    timeCost: +t,\n    parallelism: +p,\n    ...(data ? {\n      associatedData: Buffer.from(data, \"base64\")\n    } : {})\n  }), hash);\n};\n\nmodule.exports = {\n  defaults,\n  limits,\n  hash,\n  needsRehash,\n  verify,\n  ...types\n};","map":{"version":3,"names":["assert","require","randomBytes","timingSafeEqual","promisify","hash","_hash","deserialize","serialize","types","Object","freeze","argon2d","argon2i","argon2id","defaults","hashLength","saltLength","timeCost","memoryCost","parallelism","type","version","limits","min","max","names","bindingsHash","generateSalt","assertLimits","options","key","value","plain","raw","salt","entries","forEach","Buffer","from","m","t","p","associatedData","data","id","params","needsRehash","digest","v","verify","obj","length","module","exports"],"sources":["/Users/johnbrain/Projects/FlashCardProject/node_modules/argon2/argon2.js"],"sourcesContent":["\"use strict\";\nconst assert = require(\"assert\");\nconst { randomBytes, timingSafeEqual } = require(\"crypto\");\nconst { promisify } = require(\"util\");\n\nconst { hash: _hash } = require(\"./lib/binding/napi-v3/argon2.node\");\n\nconst { deserialize, serialize } = require(\"@phc/format\");\n\nconst types = Object.freeze({ argon2d: 0, argon2i: 1, argon2id: 2 });\n\nconst defaults = Object.freeze({\n  hashLength: 32,\n  saltLength: 16,\n  timeCost: 3,\n  memoryCost: 1 << 12,\n  parallelism: 1,\n  type: types.argon2id,\n  version: 0x13,\n});\n\nconst limits = Object.freeze({\n  hashLength: { min: 4, max: 2 ** 32 - 1 },\n  memoryCost: { min: 1 << 10, max: 2 ** 32 - 1 },\n  timeCost: { min: 2, max: 2 ** 32 - 1 },\n  parallelism: { min: 1, max: 2 ** 24 - 1 },\n});\n\nconst names = Object.freeze({\n  [types.argon2d]: \"argon2d\",\n  [types.argon2i]: \"argon2i\",\n  [types.argon2id]: \"argon2id\",\n});\n\nconst bindingsHash = promisify(_hash);\nconst generateSalt = promisify(randomBytes);\n\nconst assertLimits =\n  (options) =>\n  ([key, { max, min }]) => {\n    const value = options[key];\n    assert(\n      min <= value && value <= max,\n      `Invalid ${key}, must be between ${min} and ${max}.`\n    );\n  };\n\nconst hash = async (plain, { raw, salt, ...options } = {}) => {\n  options = { ...defaults, ...options };\n\n  Object.entries(limits).forEach(assertLimits(options));\n\n  salt = salt || (await generateSalt(options.saltLength));\n\n  const hash = await bindingsHash(Buffer.from(plain), salt, options);\n  if (raw) {\n    return hash;\n  }\n\n  const {\n    type,\n    version,\n    memoryCost: m,\n    timeCost: t,\n    parallelism: p,\n    associatedData: data,\n  } = options;\n  return serialize({\n    id: names[type],\n    version,\n    params: { m, t, p, ...(data ? { data } : {}) },\n    salt,\n    hash,\n  });\n};\n\nconst needsRehash = (digest, options) => {\n  const { memoryCost, timeCost, version } = { ...defaults, ...options };\n\n  const {\n    version: v,\n    params: { m, t },\n  } = deserialize(digest);\n  return +v !== +version || +m !== +memoryCost || +t !== +timeCost;\n};\n\nconst verify = async (digest, plain, options) => {\n  const obj = deserialize(digest);\n  // Only these have the \"params\" key, so if the password was encoded\n  // using any other method, the destructuring throws an error\n  if (!(obj.id in types)) {\n    return false;\n  }\n\n  const {\n    id,\n    version = 0x10,\n    params: { m, t, p, data },\n    salt,\n    hash,\n  } = obj;\n\n  return timingSafeEqual(\n    await bindingsHash(Buffer.from(plain), salt, {\n      ...options,\n      type: types[id],\n      version: +version,\n      hashLength: hash.length,\n      memoryCost: +m,\n      timeCost: +t,\n      parallelism: +p,\n      ...(data ? { associatedData: Buffer.from(data, \"base64\") } : {}),\n    }),\n    hash\n  );\n};\n\nmodule.exports = { defaults, limits, hash, needsRehash, verify, ...types };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}